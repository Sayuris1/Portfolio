local camera = require "orthographic.camera"

local TOUCH = hash("touch")
local DASH = hash("dash")

local TRIGGER = hash("trigger_response")

function init(self)
	msg.post(".", "acquire_input_focus")

    go.property("speed", 0.01)
    go.property("max_speed", 50)

    -- Cloud variables
    self.time = 0

    -- Parallax variables
    self.camera_id = go.get_id("/camera")
    self.pos_camera = go.get_position(self.camera_id)    
    self.time = 0

    -- Movement variables
    self.pos_current = go.get_position()
    self.current_speed = 0
    self.steering = vmath.vector3(0)

    -- Rotate
    self.pos_mouse = vmath.vector3(0)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
    -- Kinematic movement
    local follow_dist = self.pos_mouse - self.pos_current
    self.current_speed = self.speed * dt * vmath.length_sqr(follow_dist)

    local dir = self.steering * self.current_speed
    self.pos_current = self.pos_current + dir
    self.pos_mouse = self.pos_mouse + dir

    go.set_position(self.pos_current)

    -- Rotate to mouse
    local rotate_angle = math.atan2(follow_dist.x, follow_dist.y)
    local rotate_quat = vmath.quat_rotation_z(-rotate_angle)
    go.set_rotation(rotate_quat)
    
    -- Cloud animate
    self.pos_camera = go.get_position(self.camera_id)
    self.time = (self.time + dt) % 5
    local pos = self.pos_camera / 1000
    go.set("/cloud#quad", "u_in", vmath.vector4(pos.x, pos.y, self.time, 0))

    -- Trail
    -- Need to reset child go quat. Trail rotates itself in the shader
    go.set_rotation(vmath.quat_rotation_z(rotate_angle), "/player_trail")
end

function on_message(self, message_id, message, sender)
	if message_id == TRIGGER and message.enter then
        local collision = msg.url(message.other_id)
        collision.fragment = "collisionobject"
        msg.post(collision, "disable")

        local duration = 0.2
        local pos_particle = go.get_position(message.other_id)
        local to = pos_particle + self.steering * math.min(self.current_speed * 3, 100)
        to.z = pos_particle.z

        local url = msg.url(go.get_parent(message.other_id))
        url.fragment = "script"

        if message.group == hash(1) then
            go.animate(url, "pos_1", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        elseif message.group == hash(2) then
            go.animate(url, "pos_2", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        elseif message.group == hash(3) then
            go.animate(url, "pos_3", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        end
    end
end

function on_input(self, action_id, action)
	if action_id == TOUCH then
        local world = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
        self.pos_mouse = world

        local distance = world - self.pos_current
        distance.z = 0

        if vmath.length_sqr(distance) > 500 then
            self.steering = vmath.normalize(distance)
        end

        if action.released then
            -- Reset steering to stop moving after mouse release
            self.steering.x = 0; self.steering.y = 0
        end

    -- Mouse movement have action_id == nil
    else
        self.pos_mouse = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
    end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
