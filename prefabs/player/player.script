local camera = require "orthographic.camera"

local TOUCH = hash("touch")
local DASH = hash("dash")

local TRIGGER = hash("trigger_response")
local COLLISION = hash("contact_point_response")

function init(self)
	msg.post(".", "acquire_input_focus")

    go.property("speed", 0.01)
    go.property("max_speed", 50)

    -- Cloud variables
    self.time = 0

    -- Parallax variables
    self.camera_id = go.get_id("/camera")
    self.pos_camera = go.get_position(self.camera_id)    
    self.time = 0

    -- Movement variables
    self.pos_current = go.get_position()
    self.current_speed = 0
    self.steering = vmath.vector3(0)

    self.dash = true

    -- Rotate
    self.pos_mouse = vmath.vector3(0)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
    -- Kinematic movement
    local follow_dist = self.pos_mouse - self.pos_current
    self.current_speed = self.speed * dt * vmath.length_sqr(follow_dist)

    local dir = self.steering * self.current_speed
    self.pos_current = self.pos_current + dir
    self.pos_mouse = self.pos_mouse + dir

    -- Set trail color
    if vmath.length_sqr(dir) > 200 then
        go.animate("/player_trail#trail_model", "u_color", go.PLAYBACK_ONCE_FORWARD, vmath.vector4(1, 0, 0, 1), go.EASING_OUTEXPO, 0.5)
        if self.dash then
            self.dash = false

            -- Shockwave
            self.time = 0
            local pos = camera.world_to_screen(nil, self.pos_current)
            local shock_timer = timer.delay(0.0, true, function (self, delay)
                self.time = self.time + 0.01
                go.set("/shockwave#quad", "u_in", vmath.vector4(pos.x, pos.y, self.time, 0))
            end)
           
            -- Ship animate
            go.animate("/sprite", "scale", go.PLAYBACK_ONCE_PINGPONG, vmath.vector3(0), go.EASING_LINEAR, 0.1, 0, function ()
                go.animate("/sprite", "scale", go.PLAYBACK_ONCE_PINGPONG, vmath.vector3(0.5, 2, 1), go.EASING_LINEAR, 0.3, 0, function ()
                end)
            end)
            
            -- Ghost animate
            local dash = factory.create("#dash")
            local url = msg.url(dash); url.fragment = "sprite"
            go.animate(dash, "position", go.PLAYBACK_ONCE_FORWARD, self.pos_current, go.EASING_LINEAR, 1.8)
            go.animate(url, "u_time.x", go.PLAYBACK_ONCE_FORWARD, 1.8, go.EASING_LINEAR, 1.7, 0.0, function() 
                go.delete(dash)
                -- Stop shockwave
                go.set("/shockwave#quad", "u_in", vmath.vector4(0, 0, 0, 0))
                timer.cancel(shock_timer)
                -- Can dash again
                self.dash = true
            end)

            local dash_fx = factory.create("#dash_fx", go.get_position(), go.get_rotation(), nil, vmath.vector3(0))
            local url = msg.url(dash_fx); url.fragment = "sprite"
            go.animate(dash_fx, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0.3), go.EASING_OUTBACK, 0.5)
            go.animate(url, "u_time.x", go.PLAYBACK_ONCE_FORWARD, 1.8, go.EASING_LINEAR, 1.5)
        end
    else
        go.animate("/player_trail#trail_model", "u_color", go.PLAYBACK_ONCE_FORWARD, vmath.vector4(0, 0, 1, 1), go.EASING_OUTEXPO, 1.5)
    end

    go.set_position(self.pos_current)

    -- Rotate to mouse
    local rotate_angle = math.atan2(follow_dist.x, follow_dist.y)
    local rotate_quat = vmath.quat_rotation_z(-rotate_angle)
    go.set_rotation(rotate_quat)
    
    -- Cloud animate
    self.pos_camera = go.get_position(self.camera_id)
    local pos = self.pos_camera / 1000
    go.set("/cloud#quad", "u_in", vmath.vector4(pos.x, pos.y, 0, 0))

    -- Trail
    -- Need to reset child go quat. Trail rotates itself in the shader
    go.set_rotation(vmath.quat_rotation_z(rotate_angle), "/player_trail")

    --msg.post("/A#collisionobject", "apply_force", {force = vmath.vector3(1000, 0, 0) , position = vmath.vector3(0)})
end

function on_message(self, message_id, message, sender)
	if message_id == TRIGGER and message.enter then
        local collision = msg.url(message.other_id)
        collision.fragment = "collisionobject"
        msg.post(collision, "disable")

        local duration = 0.2
        local pos_particle = go.get_position(message.other_id)
        local to = pos_particle + self.steering * math.min(self.current_speed * 3, 100)
        to.z = pos_particle.z

        local url = msg.url(go.get_parent(message.other_id))
        url.fragment = "script"

        if message.group == hash(1) then
            go.animate(url, "pos_1", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        elseif message.group == hash(2) then
            go.animate(url, "pos_2", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        elseif message.group == hash(3) then
            go.animate(url, "pos_3", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_OUTQUAD, duration, 0, function ()
                msg.post(collision, "enable")
            end)
        end

    elseif message_id == COLLISION then
        local url = msg.url(message.other_id)
        url.fragment = "collisionobject"

        local force = self.current_speed * -message.normal * 300
        msg.post(url, "apply_force", {force = force , position = message.position})
    end
end

function on_input(self, action_id, action)
	if action_id == TOUCH then
        local world = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
        self.pos_mouse = world

        local distance = world - self.pos_current
        distance.z = 0

        if vmath.length_sqr(distance) > 500 then
            self.steering = vmath.normalize(distance)
        end

        if action.released then
            -- Reset steering to stop moving after mouse release
            self.steering.x = 0; self.steering.y = 0
        end

    -- Mouse movement have action_id == nil
    else
        self.pos_mouse = camera.screen_to_world(nil, vmath.vector3(action.x, action.y, 0))
    end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
